import { OptimizedMesh, Triangle, ConversionMetrics, Point3D } from '../types/advanced-types';

export class AdvancedSTLGenerator {
  
  /**
   * Generate optimized STL with advanced compression
   */
  public static generateOptimizedSTL(
    mesh: OptimizedMesh,
    format: 'binary' | 'ascii' = 'binary',
    compression: 'none' | 'low' | 'medium' | 'high' = 'medium'
  ): { blob: Blob; metrics: ConversionMetrics } {
    const startTime = performance.now();
    const startMemory = (performance as any).memory?.usedJSHeapSize || 0;
    
    let stlData: ArrayBuffer | string;
    let compressionRatio = 1.0;
    
    if (format === 'binary') {
      const result = this.generateBinarySTL(mesh, compression);
      stlData = result.data;
      compressionRatio = result.compressionRatio;
    } else {
      const result = this.generateASCIISTL(mesh, compression);
      stlData = result.data;
      compressionRatio = result.compressionRatio;
    }
    
    const blob = new Blob([stlData], { type: 'model/stl' });
    
    const endTime = performance.now();
    const endMemory = (performance as any).memory?.usedJSHeapSize || 0;
    
    const metrics: ConversionMetrics = {
      processingTime: endTime - startTime,
      memoryUsage: endMemory - startMemory,
      triangleCount: mesh.triangles.length,
      vertexCount: mesh.vertices.length,
      compressionRatio,
      qualityScore: mesh.quality.averageTriangleQuality
    };
    
    return { blob, metrics };
  }

  /**
   * Generate optimized binary STL
   */
  private static generateBinarySTL(
    mesh: OptimizedMesh,
    compression: 'none' | 'low' | 'medium' | 'high'
  ): { data: ArrayBuffer; compressionRatio: number } {
    // Apply mesh compression before STL generation
    const compressedMesh = this.compressMesh(mesh, compression);
    const compressionRatio = mesh.triangles.length / compressedMesh.triangles.length;
    
    // STL binary format:
    // - 80 byte header
    // - 4 byte triangle count
    // - For each triangle: 12 floats (normal + 3 vertices) + 2 byte attribute
    const triangleCount = compressedMesh.triangles.length;
    const bufferSize = 80 + 4 + (triangleCount * 50); // 50 bytes per triangle
    
    const buffer = new ArrayBuffer(bufferSize);
    const view = new DataView(buffer);
    const uint8View = new Uint8Array(buffer);
    
    // Header (80 bytes) - use meaningful header
    const header = `STL generated by Monkey Pic - Advanced 3D Converter v2.0 - ${triangleCount} triangles`;
    const headerBytes = new TextEncoder().encode(header);
    uint8View.set(headerBytes.slice(0, 80), 0);
    
    // Triangle count (4 bytes, little endian)
    view.setUint32(80, triangleCount, true);
    
    let offset = 84;
    
    // Write triangles with optimized precision
    for (const triangle of compressedMesh.triangles) {
      // Normal vector (12 bytes)
      view.setFloat32(offset, triangle.normal.x, true);
      view.setFloat32(offset + 4, triangle.normal.y, true);
      view.setFloat32(offset + 8, triangle.normal.z, true);
      offset += 12;
      
      // Vertices (36 bytes)
      for (const vertex of triangle.vertices) {
        view.setFloat32(offset, vertex.x, true);
        view.setFloat32(offset + 4, vertex.y, true);
        view.setFloat32(offset + 8, vertex.z, true);
        offset += 12;
      }
      
      // Attribute byte count (2 bytes) - use for quality encoding
      const qualityByte = Math.floor(triangle.quality * 255);
      view.setUint16(offset, qualityByte, true);
      offset += 2;
    }
    
    return { data: buffer, compressionRatio };
  }

  /**
   * Generate optimized ASCII STL
   */
  private static generateASCIISTL(
    mesh: OptimizedMesh,
    compression: 'none' | 'low' | 'medium' | 'high'
  ): { data: string; compressionRatio: number } {
    const compressedMesh = this.compressMesh(mesh, compression);
    const compressionRatio = mesh.triangles.length / compressedMesh.triangles.length;
    
    let stl = `solid MonkeyPic_Advanced_3D_Model\n`;
    
    // Determine precision based on compression level
    const precision = this.getPrecision(compression);
    
    for (const triangle of compressedMesh.triangles) {
      // Normal
      stl += `  facet normal ${triangle.normal.x.toFixed(precision)} ${triangle.normal.y.toFixed(precision)} ${triangle.normal.z.toFixed(precision)}\n`;
      stl += `    outer loop\n`;
      
      // Vertices
      for (const vertex of triangle.vertices) {
        stl += `      vertex ${vertex.x.toFixed(precision)} ${vertex.y.toFixed(precision)} ${vertex.z.toFixed(precision)}\n`;
      }
      
      stl += `    endloop\n`;
      stl += `  endfacet\n`;
    }
    
    stl += `endsolid MonkeyPic_Advanced_3D_Model\n`;
    
    return { data: stl, compressionRatio };
  }

  /**
   * Compress mesh based on quality settings
   */
  private static compressMesh(
    mesh: OptimizedMesh,
    compression: 'none' | 'low' | 'medium' | 'high'
  ): OptimizedMesh {
    if (compression === 'none') {
      return mesh;
    }
    
    // Define compression parameters
    const compressionParams = {
      low: { qualityThreshold: 0.3, decimationRatio: 0.9 },
      medium: { qualityThreshold: 0.4, decimationRatio: 0.7 },
      high: { qualityThreshold: 0.5, decimationRatio: 0.5 }
    };
    
    const params = compressionParams[compression];
    
    // 1. Remove low-quality triangles
    const qualityFiltered = mesh.triangles.filter(
      triangle => triangle.quality >= params.qualityThreshold
    );
    
    // 2. Apply decimation (simplified - remove every nth triangle based on ratio)
    const targetCount = Math.floor(qualityFiltered.length * params.decimationRatio);
    const decimated = this.applyIntelligentDecimation(qualityFiltered, targetCount);
    
    // 3. Update vertex list to only include referenced vertices
    const usedVertices = new Set<string>();
    for (const triangle of decimated) {
      for (const vertex of triangle.vertices) {
        const key = `${vertex.x.toFixed(6)},${vertex.y.toFixed(6)},${vertex.z.toFixed(6)}`;
        usedVertices.add(key);
      }
    }
    
    const compressedVertices = mesh.vertices.filter(vertex => {
      const key = `${vertex.x.toFixed(6)},${vertex.y.toFixed(6)},${vertex.z.toFixed(6)}`;
      return usedVertices.has(key);
    });
    
    return {
      vertices: compressedVertices,
      triangles: decimated,
      bounds: mesh.bounds,
      quality: {
        averageTriangleQuality: decimated.reduce((sum, t) => sum + t.quality, 0) / decimated.length,
        aspectRatio: mesh.quality.aspectRatio,
        manifoldness: mesh.quality.manifoldness
      }
    };
  }

  /**
   * Apply intelligent decimation preserving important features
   */
  private static applyIntelligentDecimation(
    triangles: Triangle[],
    targetCount: number
  ): Triangle[] {
    if (triangles.length <= targetCount) {
      return triangles;
    }
    
    // Sort triangles by importance (quality * area)
    const sortedTriangles = triangles
      .map(triangle => ({
        triangle,
        importance: triangle.quality * triangle.area
      }))
      .sort((a, b) => b.importance - a.importance);
    
    // Keep the most important triangles
    return sortedTriangles
      .slice(0, targetCount)
      .map(item => item.triangle);
  }

  /**
   * Get precision based on compression level
   */
  private static getPrecision(compression: 'none' | 'low' | 'medium' | 'high'): number {
    switch (compression) {
      case 'none': return 6;
      case 'low': return 5;
      case 'medium': return 4;
      case 'high': return 3;
      default: return 4;
    }
  }

  /**
   * Validate STL mesh integrity
   */
  public static validateSTL(mesh: OptimizedMesh): {
    isValid: boolean;
    issues: string[];
    warnings: string[];
  } {
    const issues: string[] = [];
    const warnings: string[] = [];
    
    // Check for minimum triangle count
    if (mesh.triangles.length === 0) {
      issues.push('Mesh contains no triangles');
    }
    
    // Check for degenerate triangles
    let degenerateCount = 0;
    for (const triangle of mesh.triangles) {
      if (triangle.area < 1e-6) {
        degenerateCount++;
      }
    }
    
    if (degenerateCount > 0) {
      warnings.push(`${degenerateCount} degenerate triangles detected`);
    }
    
    // Check for inverted normals
    let invertedNormalCount = 0;
    for (const triangle of mesh.triangles) {
      if (triangle.normal.z < 0) { // Assuming Z-up orientation
        invertedNormalCount++;
      }
    }
    
    if (invertedNormalCount > mesh.triangles.length * 0.1) {
      warnings.push(`${invertedNormalCount} triangles may have inverted normals`);
    }
    
    // Check mesh bounds
    const bounds = mesh.bounds;
    const size = {
      x: bounds.max.x - bounds.min.x,
      y: bounds.max.y - bounds.min.y,
      z: bounds.max.z - bounds.min.z
    };
    
    if (size.x <= 0 || size.y <= 0 || size.z <= 0) {
      issues.push('Mesh has invalid dimensions');
    }
    
    // Check for reasonable scale
    if (size.x > 1000 || size.y > 1000 || size.z > 1000) {
      warnings.push('Mesh is very large (>1000mm), consider scaling down');
    }
    
    if (size.x < 0.1 || size.y < 0.1 || size.z < 0.1) {
      warnings.push('Mesh is very small (<0.1mm), consider scaling up');
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      warnings
    };
  }

  /**
   * Optimize STL for 3D printing
   */
  public static optimizeFor3DPrinting(mesh: OptimizedMesh): OptimizedMesh {
    // 1. Ensure manifold mesh
    const manifoldMesh = this.ensureManifold(mesh);
    
    // 2. Fix orientation (ensure Z-up)
    const orientedMesh = this.fixOrientation(manifoldMesh);
    
    // 3. Add support-friendly features
    const supportOptimized = this.optimizeForSupports(orientedMesh);
    
    return supportOptimized;
  }

  /**
   * Ensure mesh is manifold (simplified implementation)
   */
  private static ensureManifold(mesh: OptimizedMesh): OptimizedMesh {
    // Simplified manifold checking - remove duplicate triangles
    const uniqueTriangles: Triangle[] = [];
    const triangleSet = new Set<string>();
    
    for (const triangle of mesh.triangles) {
      const key = triangle.vertices
        .map(v => `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`)
        .sort()
        .join('|');
      
      if (!triangleSet.has(key)) {
        triangleSet.add(key);
        uniqueTriangles.push(triangle);
      }
    }
    
    return {
      ...mesh,
      triangles: uniqueTriangles
    };
  }

  /**
   * Fix mesh orientation for 3D printing
   */
  private static fixOrientation(mesh: OptimizedMesh): OptimizedMesh {
    // Ensure all normals point outward (simplified)
    const fixedTriangles = mesh.triangles.map(triangle => {
      // If normal points downward, flip it
      if (triangle.normal.z < 0) {
        return {
          ...triangle,
          vertices: [triangle.vertices[0], triangle.vertices[2], triangle.vertices[1]] as [Point3D, Point3D, Point3D], // Flip winding
          normal: {
            x: -triangle.normal.x,
            y: -triangle.normal.y,
            z: -triangle.normal.z
          }
        };
      }
      return triangle;
    });
    
    return {
      ...mesh,
      triangles: fixedTriangles
    };
  }

  /**
   * Optimize mesh for support structures
   */
  private static optimizeForSupports(mesh: OptimizedMesh): OptimizedMesh {
    // Add gentle slopes where overhangs are too steep
    const optimizedTriangles = mesh.triangles.map(triangle => {
      const angle = Math.acos(Math.abs(triangle.normal.z));
      const degrees = (angle * 180) / Math.PI;
      
      // If overhang is too steep (>45 degrees), adjust slightly
      if (degrees > 45 && degrees < 90) {
        const adjustmentFactor = 0.95; // Slightly reduce steepness
        const adjustedVertices = triangle.vertices.map(vertex => ({
          ...vertex,
          z: vertex.z * adjustmentFactor
        }));
        
        return {
          ...triangle,
          vertices: adjustedVertices as [Point3D, Point3D, Point3D]
        };
      }
      
      return triangle;
    });
    
    return {
      ...mesh,
      triangles: optimizedTriangles
    };
  }
}
